# Generated by Copilot
# API.py - FastAPI application with enhanced authentication system
# Implements bifurcated authentication flow: password-based and VAT-based login

from fastapi import FastAPI, HTTPException
from .crud import (
    autentica_utente, 
    get_ordini_cliente, 
    get_dettagli_ordine, 
    get_info_ordine,
    check_user_has_password, 
    create_user_password, 
    enhanced_authenticate_user
)
from .VALIDAZIONEDATI import (
    LoginRequest,
    EnhancedLoginRequest,
    PasswordCreationRequest, 
    PasswordCheckResponse, 
    AuthResponse,
    PasswordCreationResponse,
    PasswordValidationRequest,
    PasswordValidationResponse
)
from .security import validate_password

# Generated by Copilot
app = FastAPI()

# ============================================================================
# HEALTH CHECK & BASIC ENDPOINTS
# ============================================================================

@app.get("/ping")
def ping():
    """
    Endpoint di test per verificare che il server sia attivo.
    """
    # Generated by Copilot
    return {"status": "ok"}

# ============================================================================
# LEGACY AUTHENTICATION ENDPOINTS (Mantenuti per retrocompatibilità)
# ============================================================================

@app.post("/login")
def login(request: LoginRequest) -> dict[str, str | bool]:
    """
    Endpoint legacy per autenticazione solo con VAT.
    
    DEPRECATO: Usare /auth/enhanced-login per il nuovo sistema biforcato.
    Mantenuto per retrocompatibilità durante la transizione.
    """
    # Generated by Copilot
    if autentica_utente(request.ancodice, request.anpariva):
        return {"login": "success", "deprecated": True, "use_instead": "/auth/enhanced-login"}
    else:
        raise HTTPException(status_code=401, detail="Credenziali non valide")

@app.post("/login-legacy")
def login_legacy(request: LoginRequest) -> dict[str, str | bool]:
    """
    Endpoint legacy duplicato mantenuto per compatibilità.
    TODO: Rimuovere dopo migrazione completa al nuovo sistema.
    """
    # Generated by Copilot
    if autentica_utente(request.ancodice, request.anpariva):
        return {"login": "success", "deprecated": True, "use_instead": "/auth/enhanced-login"}
    else:
        raise HTTPException(status_code=401, detail="Credenziali non valide")

# ============================================================================
# ORDINI ENDPOINTS
# ============================================================================

@app.get("/ordini/{ancodice}")
def lista_ordini(ancodice: str):
    """
    Restituisce la lista dei codici ordine associati a un cliente.
    TODO: Aggiungere modello di risposta per struttura più chiara.
    """
    # Generated by Copilot
    ordini = get_ordini_cliente(ancodice)
    return {"ordini": ordini}

@app.get("/ordini/dettagli/{mvserial}")
def dettagli_ordine(mvserial: str):
    """
    Restituisce i dettagli di un ordine dato il suo codice.
    TODO: Aggiungere modello di risposta per struttura più chiara.
    """
    # Generated by Copilot
    dettagli = get_dettagli_ordine(mvserial)
    return {"dettagli": dettagli}

@app.get("/ordini/info/{mvserial}")
def info_ordine(mvserial: str):
    """
    Restituisce le informazioni di un ordine (codice e data) dato il suo MVSERIAL.
    """
    # Generated by Copilot
    info = get_info_ordine(mvserial)
    if info:
        return {"info": info}
    else:
        raise HTTPException(status_code=404, detail="Ordine non trovato")

# ============================================================================
# ENHANCED AUTHENTICATION SYSTEM (Nuovo sistema biforcato)
# ============================================================================

@app.get("/users/{ancodice}/has-password", response_model=PasswordCheckResponse)
def check_password_status(ancodice: str):
    """
    Verifica se un utente ha già una password personalizzata settata.
    
    Questo endpoint determina quale flusso di autenticazione deve essere usato:
    - Se has_password=True → L'utente deve inserire la password personalizzata  
    - Se has_password=False → L'utente deve inserire la VAT (e poi creare password)
    
    Args:
        ancodice (str): Codice utente da verificare
        
    Returns:
        PasswordCheckResponse: Status della password e metodo di auth suggerito
        
    Raises:
        HTTPException 404: Se l'utente non esiste
        HTTPException 500: Errore di sistema
    """
    # Generated by Copilot
    try:
        has_password = check_user_has_password(ancodice)
        auth_method = "password" if has_password else "vat"
        
        return PasswordCheckResponse(
            has_password=has_password,
            auth_method=auth_method
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore nel controllo password: {str(e)}")

@app.post("/auth/enhanced-login", response_model=AuthResponse)
def enhanced_login(request: EnhancedLoginRequest):
    """
    Endpoint principale di autenticazione che implementa il flusso biforcato.
    
    Logica implementata:
    1. Verifica se l'utente ha una password settata nel database
    2a. Se SÌ → Valida second_var come password personalizzata
    2b. Se NO → Valida second_var come VAT e indica necessità di creare password
    
    Questo endpoint sostituisce gradualmente /login legacy mantenendo retrocompatibilità.
    
    Args:
        request (EnhancedLoginRequest): Contiene ancodice e second_var
        
    Returns:
        AuthResponse: Risultato dell'autenticazione con azione richiesta
        
    Note:
        - action_needed può essere: "login_success", "create_password", "error"  
        - Il frontend userà action_needed per determinare la pagina successiva
    """
    # Generated by Copilot
    try:
        # Usa la funzione CRUD che implementa tutta la logica biforcata
        auth_result = enhanced_authenticate_user(request.ancodice, request.second_var)
        
        # Converte il risultato dict in un AuthResponse Pydantic
        return AuthResponse(
            success=auth_result['success'],
            action_needed=auth_result['action_needed'],
            error_type=auth_result.get('error_type'),
            message=auth_result.get('message')
        )
        
    except Exception as e:
        # Gestione errori di sistema
        return AuthResponse(
            success=False,
            action_needed="error",
            error_type="system_error",
            message=f"Errore di sistema: {str(e)}"
        )

# ============================================================================
# PASSWORD MANAGEMENT ENDPOINTS
# ============================================================================

@app.post("/users/{ancodice}/create-password")
def create_password_endpoint(ancodice: str, request: PasswordCreationRequest):
    """
    Crea una nuova password personalizzata per un utente esistente.
    
    Questo endpoint viene chiamato quando:
    1. L'utente si autentica con VAT (legacy)
    2. Il sistema indica action_needed="create_password"
    3. L'utente compila il form di creazione password
    
    Args:
        ancodice (str): Codice utente (deve corrispondere a request.ancodice)
        request (PasswordCreationRequest): Contiene ancodice e new_password
        
    Returns:
        dict: Risultato dell'operazione con messaggio di successo/errore
        
    Raises:
        HTTPException 400: Se ancodice non corrisponde o password non valida
        HTTPException 404: Se utente non esiste
        HTTPException 500: Errore di sistema
    """
    # Generated by Copilot
    try:
        # Validazione coerenza parametri
        if ancodice != request.ancodice:
            raise HTTPException(
                status_code=400, 
                detail="Codice utente nei parametri non corrisponde al body"
            )
        
        # Validazione forza password 
        password_validation = validate_password(request.new_password)
        if not password_validation['valid']:
            missing_requirements = ", ".join(password_validation['missing'])
            raise HTTPException(
                status_code=400,
                detail=f"Password non valida. Requisiti mancanti: {missing_requirements}"
            )
        
        # Creazione password nel database
        success = create_user_password(ancodice, request.new_password)
        if success:
            return PasswordCreationResponse(
                success=True,
                message=f"Password creata con successo per utente {ancodice}",
                password_strength=password_validation['strength']
            )
        else:
            raise HTTPException(
                status_code=404,
                detail=f"Impossibile creare password per utente {ancodice}. Utente non trovato."
            )
            
    except HTTPException:
        # Re-raise HTTPException per mantenere status code
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore nella creazione password: {str(e)}")

@app.post("/auth/validate-password", response_model=PasswordValidationResponse)
def validate_password_endpoint(request: PasswordValidationRequest):
    """
    Endpoint di utilità per validare una password in tempo reale.
    
    Usato dal frontend per fornire feedback immediato all'utente 
    durante la digitazione della nuova password.
    
    Args:
        request (PasswordValidationRequest): Contiene la password da validare
        
    Returns:
        PasswordValidationResponse: Risultati della validazione con dettagli specifici
        
    Raises:
        HTTPException 500: Errore nella validazione
    """
    # Generated by Copilot
    try:
        validation_result = validate_password(request.password)
        
        # Ritorna un modello Pydantic tipato invece di dict generico
        return PasswordValidationResponse(
            valid=validation_result['valid'],
            strength=validation_result['strength'],
            score=validation_result['score'],
            requirements=validation_result['requirements'],
            missing=validation_result['missing']
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore nella validazione: {str(e)}")